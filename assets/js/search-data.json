{
  
    
        "post0": {
            "title": "Basic Python",
            "content": "Learning Tip . We Strongly recommand learning with playing. We provide the notebook for student to get started. And if you ever get trouble with learning, please feel free to reach out to us. . Data Type . Data Type of a variable describe the properties that variable hold. There are four basic Data Type in Python: . Int | Float | String | Boolean | For example, &quot;Hello World&quot; is a String data type. We could use String to print the output for user to see. For calculation, we could use Int and Float data type. eg. . num1 = 3 num2 = 5 print(num1 + num2) . 8 . String . a = &quot;hello world&quot; print(type(a)) print(a) print() . Int . a = 10 print(type(a)) print(a) print() . Float . a = 10.0 print(type(a)) print(a) print() . Boolean . a = True print(type(a)) print(a) print() . Operations on Data Type . There are many built-in, already implemented, operations we could do in python. Like, for example, for arithemetic operations: . Addition (+) | Subtraction (-) | Multiplication (*) | Division (/) | Arithemetic operations, as the name suggest, can only be used in Int and Float Data Type. . For two String data type are added, it will just connect the two values. . a = 10 b = 12 astring = &quot;Hello .&quot; bstring = &quot;. User&quot; # Add print(&#39;Adding Two Integers&#39;) print(a + b) print() print(&#39;Adding Two Strings&#39;) print(astring + bstring) print() # Subtract print(&#39;Subtracting&#39;) print(a - b) print() # Multiply print(&#39;Multiplying&#39;) print(a * b) print() # Division print(&#39;Division&#39;) print(a / b) print() . . Adding Two Integers 22 Adding Two Strings Hello .. User Subtracting -2 Multiplying 120 Division 0.8333333333333334 . . Note: We could only do operations on the same data type. For example, Int variable and String variable could not be added (will raise an error). . a = 10 b = &#39;hello world&#39; print(a + b) . . TypeError Traceback (most recent call last) &lt;ipython-input-4-857b62d6dea8&gt; in &lt;module&gt; 2 a = 10 3 b = &#39;hello world&#39; -&gt; 4 print(a + b) TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39; . Data Structure . Data Structure is a collection of variables. Based on the method of collecting the varibles, the four basic data structure are presented in Python. . List | Tuple | Dictionary | Set | # Creat different Data Structure # list list_var = [1, 2, 3, 1, 2, 3] # tuple tuple_var = (1, 2, 3, 1, 2, 3) # dictionary dict_var = {&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:1, &#39;e&#39;:2, &#39;f&#39;:3} # set set_var = {1, 2, 3, 1, 2, 3} print(&quot;List : &quot;, list_var) print(&quot;Tuple : &quot;, tuple_var) print(&quot;Dictionary : &quot;, dict_var) print(&quot;Set : &quot;, set_var) . . List : [1, 2, 3, 1, 2, 3] Tuple : (1, 2, 3, 1, 2, 3) Dictionary : {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 1, &#39;e&#39;: 2, &#39;f&#39;: 3} Set : {1, 2, 3, &#39;eh&#39;} . List . The most commonly used data structure in python because of the following properties. . Access element in Ordered | Mutable | Tuple . Access element in Ordered | Immutable | Dictionary . Unordered | Key-Value paired | Set . Unordered | Exclusive | Conditional Loop . if-else . for . while . Functions . Class . Reference .",
            "url": "https://aungpaing98.github.io/Computer_Vision_Blog/image_processing/overview/2020/12/30/python-basic.html",
            "relUrl": "/image_processing/overview/2020/12/30/python-basic.html",
            "date": " • Dec 30, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Basic Image Processing with Python",
            "content": "Image Acquisition . Images, taken from real life with camera, and then stored in computer. In computer, the images are stored with digital(numbers) format. . We can read in that image stored in computer with code: . img = matplotlib.image.imread(img_name) . Typical img would contain 3 dimension(channel) of color space, we called it RGB as shown in above fig. We could inspect the dimension(channel) of image in code with: . h, w, d = img.shape . In the above mario image, since, the height and width are both 16, 16, h and w would be 16 and d would be 3. So, it is a 16*16*3 (RGB) image. . Arithemetic Operations . Since Images are actually numbers, we could use functions to operate on the images. The most basic function would be adding, subtracting, multiply and division. Here, we will first introduce Adding and Subtracting. . import matplotlib.image as mpimg import matplotlib.pyplot as plt import numpy as np import cv2 . # Helper Function for showing Images def imShow(imgs, titles=None): num = len(imgs) x = (num//4)+1 y = int(np.ceil(num/x)) plt.figure(figsize=(18,15)) for i in range(num): plt.subplot(x, y, i+1) cmap=None title=None if imgs[i].ndim==2:cmap=&#39;gray&#39; if titles!=None:title=titles[i] plt.imshow(imgs[i], cmap=cmap) plt.title(title,fontdict={&#39;fontsize&#39;:23}) plt.tight_layout() plt.show() . . Subtract Two Images . In the below Image, the subtracted result shows the difference between two images. . Note: While subtracting, we need to be careful of the dtype range. Because image array are in range of 0 ~ 255. If it is negative value, it will subtract that negative value with 256. . Below show the example . &#39;&#39;&#39;Because &#39;b&#39; is in the range of 0 ~ 255, while it exceed that value, it will subtract from 256. eg. here, &#39;b&#39; should be -5, so, it would be &#39;256-5 = 251&#39; &#39;&#39;&#39; a = np.array([5]) b = (a-10).astype(np.uint8) print(b) . . [251] . img1 = mpimg.imread(&#39;1.jpg&#39;) img2 = mpimg.imread(&#39;2.jpg&#39;) # First let&#39;s check their dimension assert img1.shape == img2.shape # Extend range so there won&#39;t be gibberish # diff = img2 - img1 diff = img2.astype(np.int16) - img1.astype(np.int16) diff[diff&lt;0] = 0 imShow([img1, img2, diff], [&#39;img1&#39;, &#39;img2&#39;, &#39;Difference&#39;]) . . Add Two Images . We could add two images if they are in the same Dimension. . img1 = mpimg.imread(&#39;bird.jpg&#39;) img2 = mpimg.imread(&#39;back.jpg&#39;) h, w, d = img2.shape print(f&#39;Before resize : &#39;, img1.shape, img2.shape) img1 = cv2.resize(img1, (w, h)) print(f&#39;After resize : &#39;, img1.shape, img2.shape) add = img2.astype(np.int16) + img1.astype(np.int16) add[add&gt;255] = 255 imShow([img1, img2, add]) . . Before resize : (478, 717, 3) (421, 748, 3) After resize : (421, 748, 3) (421, 748, 3) . . Important: Both Adding and Subtracting two images need to have both same dimension for both inputs. . Geometric Transformations . Rotation, Crop . Rotation in the image is achieved by applying the transformation matrix to the image. | . M = cv2.getRotationMatrix2D((center_x, center_y), angle_to_rotate, scale) rotated = cv2.warpAffine(img, M, (x, y)) . Cropping is just simply Slicing of the image(numpy array). | . cropped = img[x_coor:x_coor, y_coor:y_coor] . # Rotation img = mpimg.imread(&#39;tower.jpg&#39;) h, w, d = img.shape simple = cv2.rotate(img, cv2.cv2.ROTATE_90_CLOCKWISE) # More Flexible This Way M = cv2.getRotationMatrix2D((w/2, h/2), 90, 1) rotated = cv2.warpAffine(img, M, (h+100, w)) M = cv2.getRotationMatrix2D((w//2, h//2), 45, 0.5) rotated_ = cv2.warpAffine(img, M, (w, h)) imShow([img, simple, rotated, rotated_], [&#39;Tower&#39;, &#39;Simple Rotate&#39;, &#39;90 degree Rotated&#39;, &#39;45 degree Rotated&#39;]) . . # Crop [Image Slicing] img_copy = np.copy(img) door = img_copy[420:, 150:250, :] bicycle = img_copy[500:, 270:, :] imShow([img, door, bicycle], [&#39;Original Image&#39;, &#39;Door&#39;, &#39;Bicycle&#39;]) . . Color Image Transformation . RGB -&gt; BGR -&gt; HSV . Image can be converted to various color space by cv2.cvtColor(src, cv2.COLOR_). . Typically, if the image is read with matplotlib.image.imread(file_name), then it would read in with RGB format. And matplotlib.pyplot.imshow(img_array) would read the array as RGB format and display it. . While cv2.imread(file_name) would read in with BGR format and cv2.imshow() display as it take the array in BGR format. . Warning: read with matplotlib and plot with cv2 will result in Color space shift. . img = mpimg.imread(&#39;parrot.jpg&#39;) bgr = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) imShow([img, bgr], [&#39;Original Image&#39;, &#39;BGR Image&#39;]) . . Unlike other color space, in HSV, the range for hue is from 0 ~ 179. . Hue value actually represent what we human understand of color. . eg. For red color, hue value would always be 0, regardless of the change in brightness and saturation. . img = mpimg.imread(&#39;parrot.jpg&#39;) hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV) h = hsv[:, :, 0];s = hsv[:, :, 1];v = hsv[:, :, 2] print(&#39;hue t t&#39;, np.min(h), np.max(h), &#39; nsaturation t&#39;, np.min(s), np.max(s), &#39; nvalue t t&#39;, np.min(v), np.max(v)) imShow([h, s, v], [&#39;Hue&#39;, &#39;Saturation&#39;, &#39;Value&#39;]) . . hue 0 179 saturation 0 255 value 0 255 . Resizing Image . For the resizing, there are two cases: . Downsampling (Resized Image have lesser resolution than original One) | Upsampling (Resized Image have more resolution than original One) | . Also, there are many Interpolation methods to achieve resizing: . INTER_NEAREST (nearest-neighbour interpolation) | INTER_LINEAR (bilinear interpolation) | INTER_AREA (pixel area relation interpolation) [preferred for downsampling] | INTER_CUBIC (bicubic interpolation) | INTER_LANCZOS4 (lanczos interpolation) | . | . resized = cv2.resize(img, resized_dimension, interpolations=methods) . # Resizing img = mpimg.imread(&#39;lenna.png&#39;) h, w, d = img.shape dims = (w//2, h//2) dims_ = (w*2, h*2) downscale = cv2.resize(img, dims, interpolation=cv2.INTER_AREA) upscale = cv2.resize(img, dims_, interpolation=cv2.INTER_CUBIC) upscale_ = cv2.resize(img, dims_, interpolation=cv2.INTER_AREA) img = img[100:160, 100:160] downscale = downscale[50:80, 50:80] upscale = upscale[200:320, 200:320] upscale_ = upscale_[200:320, 200:320] imShow([img, downscale, upscale, upscale_], [f&#39;Original Image : {img.shape}&#39;, f&#39;Downscale Image : {downscale.shape}&#39;, f&#39;Upscale_cubic&#39;, f&#39;Upscale_area&#39;]) . . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . Image Enhancing . Sometime, we get the image that is too dark or too bright, that it lose the information for the image. . For that, we could use transform in gray scale to hightlight the place in the image that we interest in. . The basic methods for that would be : . Negative | Log Transform | Gamma Transform | Contrast Stretching (Normalization) | Histogram Equalization | Here, we will focus on the first three method. . Note: Here, We show with just gray scale, But you can always try with all 3 Color spaces and stack them later with np.dstack((r, g, b)) if it is the color image. . Negative . Effect : Bright region turn to dark and dark region turn to bright.(invert of image). . Equation : $$y = 255-x$$ . Log Transform . Effect : Add brightness to where the image is dark. . Equation : $$y = log(c+x)$$ where : $c$ = constance, $x$ = Normalized pixel . Code : . # Normalized Image x = x/255 y = np.log(c + x) . Gamma Transform . Effect : Adjustable change in brightness with gamma value. . Equation : $$y = x**r$$ where : $r$ = gamma . Code : . # Normalized Image x = x/255 y = x**r . img_names = [&#39;bird.jpg&#39;, &#39;F3.jpg&#39;, &#39;PCL.jpg&#39;, &#39;cells.jpg&#39;, &#39;tree.jpg&#39;] for img_name in img_names: img = mpimg.imread(img_name) if img.ndim&gt;=3: img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) negative = 255-img img_copy = np.copy(img).astype(np.float32) img_copy /= 255 log = np.log(1.0+img_copy) # imShow([img, negative, log], [&#39;Orignal Image&#39;, &#39;Negative Image&#39;, &#39;Log Image&#39;]) imShow([img, negative, log], [&#39;Orignal Image&#39;, &#39;Negative&#39;, &#39;Log Image&#39;]) . . And Gamma correction with difference gamma value : . gamma0 = 0.5 gamma1 = 1 gamma2 = 1.5 img = mpimg.imread(&#39;tree.jpg&#39;) if img.ndim&gt;=3: img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) r0 = 1/gamma0 result0 = (img/255)**r0 r1 = 1/gamma1 result1 = (img/255)**r1 r2 = 1/gamma2 result2 = (img/255)**r2 imShow([img, result0, result1, result2], [&#39;original image&#39;, f&#39;gamma value : {gamma0}&#39;, f&#39;gamma value : {gamma1}&#39;, f&#39;gamma value : {gamma2}&#39;]) . . As Gamma value increase, the image get brighter. . Image Gradient . Edge Detection . Edge detection is the process of finding the boundaries (shape) of objects in the image. It works by detecting the change in pixel value in the image. . There are many ways to find the edge in the image. Mainly difference in the filter. Here, we will introduce two mostly used filter. . Sobel Filter (L1)sobel = cv2.Sobel(img, filter_size, dx, dy) . | Laplacian Filter (L2)laplace = cv2.Laplacian(img, cv2.CV_64F, ksize) . | After finding the edge, we could also use that to sharpen(enhance the edge) the image. So, we could Smooth (Blur) the image and sharp the image. . Smoothing (Blurring) Image . Commanly used method: . Gaussian Filterblurred = cv2.GaussianBlur(img, filter_size(tuple), std) . | Median Filter (Used to filter salt noise) . blurred = cv2.medianBlur(img, filter_size(int)) . Belowing show the Difference in Edge detection Method. . | def sobelEdge(img): sobelx = np.abs(cv2.Sobel(img, 3, 0, 1)).astype(np.uint32) sobely = np.abs(cv2.Sobel(img, 3,1, 0)).astype(np.uint32) sobel = np.sqrt(np.square(sobelx) + np.square(sobely)) sobel = (sobel/np.max(sobel)) * 255 return sobel.astype(np.uint8) def laplaceEdge(img): laplace = np.abs(cv2.Laplacian(img, cv2.CV_64F, ksize=3)) laplace = ((laplace/np.max(laplace)) * 255).astype(np.uint8) return laplace img_names = [&#39;dark.jpg&#39;, &#39;page.jpg&#39;,&#39;tower.jpg&#39;] for img_name in img_names: img = mpimg.imread(img_name) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) sobel = sobelEdge(gray) laplace = laplaceEdge(gray) imShow([gray, sobel, laplace], [f&#39;Original image{img.shape}&#39;, f&#39;Sobel{sobel.shape}&#39;, f&#39;Laplacian{laplace.shape}&#39;]) . . And the result of Smoothing and Sharpening of images. . def smooth(img): blurred = cv2.GaussianBlur(img, (9,9), 1) return blurred def sharp(img): blurred = cv2.GaussianBlur(img, (5, 5), 1).astype(np.float32) img = img.astype(np.float32) result = np.abs((1.5*img) - (0.5*blurred)) result = ((result/np.max(result)) * 255).astype(np.uint8) return result blurred = smooth(gray) sharped = sharp(gray) door = gray[420:, 150:250] door_blurred = blurred[420:, 150:250] door_sharped = sharped[420:, 150:250] imShow([gray, blurred, sharped, door, door_blurred, door_sharped], [&#39;Original Image&#39;, &#39;Smoothed Image&#39;, &#39;Sharped Image&#39;, &quot;Original Door&quot;, &#39;Blurred Door&#39;, &#39;Sharped Door&#39;]) . . Image Segmentation . The image show in plt.imshow() typically take three types of range. . uint8, range from (0~255)[total of 256 level] | float64, range from (0~1)[total of many floating level]&lt;eg. 0.1, 0.11, 0.111&gt; | Binary Image, contain only (0 and 1)[2 level]&lt;0 mean dark and 1 mean light&gt; | . Usually, we use binary image in Mask. . 1 mean object and 0 mean background. . # Gray Scale Image img1 = np.array([[0, 50, 100, 150, 200, 255], [0, 50, 100, 150, 200, 255], [0, 50, 100, 150, 200, 255], [0, 50, 100, 150, 200, 255]]) # Binary Image img2 = np.array([[0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1]]) imShow([img1, img2], [&#39;Gray scale Image&#39;, &#39;Binary Image&#39;]) . . For the thresholding, two methods can be used. . Global Thresholding (one threshold value for all region in the image) | Typically, we set the threshold value to random number, or we find the best threshold value by trial and error. Or we can use **otsu** method, which find the optimized threshold value from intensity histogram of image. . Adaptive Thresholding | Since the lighting condition in different region in a single image can be different, Adaptive thresholding method is often better than global method. . Adaptive threshold use difference threshold value in different region. . # Global Threshold img = mpimg.imread(&#39;page.jpg&#39;) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) # 0 ~ 255 gray = cv2.medianBlur(gray, 5) glob_thresh = np.ones_like(gray) glob_thresh[gray&lt;25] = 0 # 0 &amp; 1 adap_thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 3) _, otsu_thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU) imShow([gray, glob_thresh, otsu_thresh, adap_thresh], [&#39;gray&#39;, &#39;global_threshold&#39;, &#39;otsu_Threshold&#39;, &#39;Adaptive_threshold&#39;]) . . Since thresholding process is transforming gray scale image to Binary one, it is also called binarization. . Different method for thresholding would be useful in different scenerios.The best way to find the best method is by trial and error. . For example, althought gobal thresholding method may not give better result than adaptive one, but its speed is faster casue there is not need to find the threshold value, by assigned by the user. . Morphological Transformations . Morphological transform is the transformation of shape in the binarization image. Typically used to modify the Mask (Binary Image). . Mostly Used methods are called: . Erosion (Reduce Shape) | Dilation (Expand Shape) | And the combination of these methods evolved to: . Opening (Disconnect closely related part) | Closing (Connect closely related Part) | img = mpimg.imread(&#39;cells.jpg&#39;) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) gray = cv2.medianBlur(gray, 5) gray = gray[30:, :] # Let&#39;s do some thresholding thresh = np.zeros_like(gray) # threshold value here get by trial and error thresh[gray&gt;175] = 1 kernel = np.ones((5,5), np.uint8) #Erosion eroded = cv2.erode(thresh, kernel, iterations=1) #Dilation dilated = cv2.dilate(thresh, kernel, iterations=1) # Opening (Erosion + Dilation) opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel) # Closing (Dilation + Erosion) closing = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel) imShow([gray, thresh, eroded, dilated, opening, closing], [&#39;Gray Scale Image&#39;, &#39;Binary Threshold Image&#39;, &#39;Eroded Image&#39;, &#39;Dilated Image&#39;, &#39;Morpho Open&#39;, &#39;Morpho Close&#39;]) . . In Opening, the method open(separate) the closely connected part. Opening is achieved by first erosion, then dilation. . In Closing, the method close(connect) the closely connected part. Closing is achieved by first dilation, then erosion. . thresh_ = thresh[100:200, 150:250] open_ = opening[100:200, 150:250] close_ = closing[100:200, 150:250] imShow([thresh_, open_, close_], [&#39;Original Binary&#39;, &#39;Opeing&#39;, &#39;Closing&#39;]) . . Conclusion . The Above mentioned methods are all just basic image processing techniques. There are certainly many more state of the art algorithms. . But, If we get the idea that image are numbers and various functions could be apply to the image, then, we could modify and create intereting projects in computer vision. .",
            "url": "https://aungpaing98.github.io/Computer_Vision_Blog/image_processing/overview/2020/11/22/image_processing_overview.html",
            "relUrl": "/image_processing/overview/2020/11/22/image_processing_overview.html",
            "date": " • Nov 22, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": ". :raised_hand: Hello, welcome to know me better ! :man: Aung Paing :fire: Mechatronic :eyes: Computer Vision :rocket: AI :basketball: Ball :movie_camera: Anime :movie_camera: Youtuber . Reach Me on :link: YouTube :link: Blogging :link: FaceBook .",
          "url": "https://aungpaing98.github.io/Computer_Vision_Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://aungpaing98.github.io/Computer_Vision_Blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}